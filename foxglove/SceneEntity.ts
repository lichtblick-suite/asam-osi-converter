// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.14.0
// source: foxglove/SceneEntity.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../google/protobuf/duration";
import { Timestamp } from "../google/protobuf/timestamp";
import { ArrowPrimitive } from "./ArrowPrimitive";
import { CubePrimitive } from "./CubePrimitive";
import { CylinderPrimitive } from "./CylinderPrimitive";
import { KeyValuePair } from "./KeyValuePair";
import { LinePrimitive } from "./LinePrimitive";
import { ModelPrimitive } from "./ModelPrimitive";
import { SpherePrimitive } from "./SpherePrimitive";
import { TextPrimitive } from "./TextPrimitive";
import { TriangleListPrimitive } from "./TriangleListPrimitive";

export const protobufPackage = "foxglove";

/** A visual element in a 3D scene. An entity may be composed of multiple primitives which all share the same frame of reference. */
export interface SceneEntity {
  /** Timestamp of the entity */
  timestamp:
    | Date
    | undefined;
  /** Frame of reference */
  frameId: string;
  /** Identifier for the entity. A entity will replace any prior entity on the same topic with the same `id`. */
  id: string;
  /** Length of time (relative to `timestamp`) after which the entity should be automatically removed. Zero value indicates the entity should remain visible until it is replaced or deleted. */
  lifetime:
    | Duration
    | undefined;
  /** Whether the entity should keep its location in the fixed frame (false) or follow the frame specified in `frame_id` as it moves relative to the fixed frame (true) */
  frameLocked: boolean;
  /** Additional user-provided metadata associated with the entity. Keys must be unique. */
  metadata: KeyValuePair[];
  /** Arrow primitives */
  arrows: ArrowPrimitive[];
  /** Cube primitives */
  cubes: CubePrimitive[];
  /** Sphere primitives */
  spheres: SpherePrimitive[];
  /** Cylinder primitives */
  cylinders: CylinderPrimitive[];
  /** Line primitives */
  lines: LinePrimitive[];
  /** Triangle list primitives */
  triangles: TriangleListPrimitive[];
  /** Text primitives */
  texts: TextPrimitive[];
  /** Model primitives */
  models: ModelPrimitive[];
}

function createBaseSceneEntity(): SceneEntity {
  return {
    timestamp: undefined,
    frameId: "",
    id: "",
    lifetime: undefined,
    frameLocked: false,
    metadata: [],
    arrows: [],
    cubes: [],
    spheres: [],
    cylinders: [],
    lines: [],
    triangles: [],
    texts: [],
    models: [],
  };
}

export const SceneEntity: MessageFns<SceneEntity> = {
  encode(message: SceneEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.frameId !== "") {
      writer.uint32(18).string(message.frameId);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.lifetime !== undefined) {
      Duration.encode(message.lifetime, writer.uint32(34).fork()).join();
    }
    if (message.frameLocked !== false) {
      writer.uint32(40).bool(message.frameLocked);
    }
    for (const v of message.metadata) {
      KeyValuePair.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.arrows) {
      ArrowPrimitive.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.cubes) {
      CubePrimitive.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.spheres) {
      SpherePrimitive.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.cylinders) {
      CylinderPrimitive.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.lines) {
      LinePrimitive.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.triangles) {
      TriangleListPrimitive.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.texts) {
      TextPrimitive.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.models) {
      ModelPrimitive.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SceneEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.frameId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lifetime = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.frameLocked = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata.push(KeyValuePair.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.arrows.push(ArrowPrimitive.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cubes.push(CubePrimitive.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.spheres.push(SpherePrimitive.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.cylinders.push(CylinderPrimitive.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lines.push(LinePrimitive.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.triangles.push(TriangleListPrimitive.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.texts.push(TextPrimitive.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.models.push(ModelPrimitive.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SceneEntity {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      frameId: isSet(object.frameId) ? globalThis.String(object.frameId) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      lifetime: isSet(object.lifetime) ? Duration.fromJSON(object.lifetime) : undefined,
      frameLocked: isSet(object.frameLocked) ? globalThis.Boolean(object.frameLocked) : false,
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => KeyValuePair.fromJSON(e))
        : [],
      arrows: globalThis.Array.isArray(object?.arrows) ? object.arrows.map((e: any) => ArrowPrimitive.fromJSON(e)) : [],
      cubes: globalThis.Array.isArray(object?.cubes) ? object.cubes.map((e: any) => CubePrimitive.fromJSON(e)) : [],
      spheres: globalThis.Array.isArray(object?.spheres)
        ? object.spheres.map((e: any) => SpherePrimitive.fromJSON(e))
        : [],
      cylinders: globalThis.Array.isArray(object?.cylinders)
        ? object.cylinders.map((e: any) => CylinderPrimitive.fromJSON(e))
        : [],
      lines: globalThis.Array.isArray(object?.lines) ? object.lines.map((e: any) => LinePrimitive.fromJSON(e)) : [],
      triangles: globalThis.Array.isArray(object?.triangles)
        ? object.triangles.map((e: any) => TriangleListPrimitive.fromJSON(e))
        : [],
      texts: globalThis.Array.isArray(object?.texts) ? object.texts.map((e: any) => TextPrimitive.fromJSON(e)) : [],
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => ModelPrimitive.fromJSON(e)) : [],
    };
  },

  toJSON(message: SceneEntity): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.frameId !== "") {
      obj.frameId = message.frameId;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.lifetime !== undefined) {
      obj.lifetime = Duration.toJSON(message.lifetime);
    }
    if (message.frameLocked !== false) {
      obj.frameLocked = message.frameLocked;
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => KeyValuePair.toJSON(e));
    }
    if (message.arrows?.length) {
      obj.arrows = message.arrows.map((e) => ArrowPrimitive.toJSON(e));
    }
    if (message.cubes?.length) {
      obj.cubes = message.cubes.map((e) => CubePrimitive.toJSON(e));
    }
    if (message.spheres?.length) {
      obj.spheres = message.spheres.map((e) => SpherePrimitive.toJSON(e));
    }
    if (message.cylinders?.length) {
      obj.cylinders = message.cylinders.map((e) => CylinderPrimitive.toJSON(e));
    }
    if (message.lines?.length) {
      obj.lines = message.lines.map((e) => LinePrimitive.toJSON(e));
    }
    if (message.triangles?.length) {
      obj.triangles = message.triangles.map((e) => TriangleListPrimitive.toJSON(e));
    }
    if (message.texts?.length) {
      obj.texts = message.texts.map((e) => TextPrimitive.toJSON(e));
    }
    if (message.models?.length) {
      obj.models = message.models.map((e) => ModelPrimitive.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SceneEntity>, I>>(base?: I): SceneEntity {
    return SceneEntity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SceneEntity>, I>>(object: I): SceneEntity {
    const message = createBaseSceneEntity();
    message.timestamp = object.timestamp ?? undefined;
    message.frameId = object.frameId ?? "";
    message.id = object.id ?? "";
    message.lifetime = (object.lifetime !== undefined && object.lifetime !== null)
      ? Duration.fromPartial(object.lifetime)
      : undefined;
    message.frameLocked = object.frameLocked ?? false;
    message.metadata = object.metadata?.map((e) => KeyValuePair.fromPartial(e)) || [];
    message.arrows = object.arrows?.map((e) => ArrowPrimitive.fromPartial(e)) || [];
    message.cubes = object.cubes?.map((e) => CubePrimitive.fromPartial(e)) || [];
    message.spheres = object.spheres?.map((e) => SpherePrimitive.fromPartial(e)) || [];
    message.cylinders = object.cylinders?.map((e) => CylinderPrimitive.fromPartial(e)) || [];
    message.lines = object.lines?.map((e) => LinePrimitive.fromPartial(e)) || [];
    message.triangles = object.triangles?.map((e) => TriangleListPrimitive.fromPartial(e)) || [];
    message.texts = object.texts?.map((e) => TextPrimitive.fromPartial(e)) || [];
    message.models = object.models?.map((e) => ModelPrimitive.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
